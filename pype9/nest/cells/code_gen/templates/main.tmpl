{% import "macros.tmpl" as macros %}

{% macro elseif(first) %}{% if first %}if{% else %}} else if{% endif %}{% endmacro %}
{% macro endif(last) %}{% if last %}}{% endif %}{% endmacro %}
{% set debug = False %}

/* This file was generated by PyPe9 version {{version}} on {{timestamp}} */

#include <limits>
#include <iomanip>
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>

#include "{{component_name}}.h"
#include "exceptions.h"
#include "network.h"
#include "dict.h"
#include "integerdatum.h"
#include "doubledatum.h"
#include "dictutils.h"
#include "numerics.h"
#include "universal_data_logger_impl.h"

/******************************************************************
 * Template specialization that needs to be in the nest namesapce *
 ******************************************************************/

nest::RecordablesMap<nineml::{{component_name}}> nineml::{{component_name}}::recordablesMap_;

namespace nest{
  template <> void RecordablesMap<nineml::{{component_name}}>::create() {
{% for sv in component_class.state_variables %}
    insert_("{{sv.name}}", &nineml::{{component_name}}::get_y_elem_<nineml::{{component_name}}::State_::{{sv.name}}_INDEX>);
{% endfor %}
  }
}

/************************************************
 * Evaluation of dynamics for a single timestep *
 ************************************************/

namespace nineml {

extern "C" void {{component_name}}_dump_gsl_state(gsl_odeiv2_evolve * e, double y[]) {

    std::cout << "y0:";
    for (unsigned int i = 0; i < e->dimension; ++i)
        std::cout << e->y0[i] << " ";
    std::cout << std::endl;
    std::cout << "yerr:";
    for (unsigned int i = 0; i < e->dimension; ++i)
        std::cout << e->yerr[i] << " ";
    std::cout << std::endl;
    std::cout << "dydt_in:";
    for (unsigned int i = 0; i < e->dimension; ++i)
        std::cout << e->dydt_in[i] << " ";
    std::cout << std::endl;
    std::cout << "dydt_out:";
    for (unsigned int i = 0; i < e->dimension; ++i)
        std::cout << e->dydt_out[i] << " ";
    std::cout << std::endl;
    std::cout << "last_step:" << e->last_step << std::endl;
    std::cout << "count:" << e->count << std::endl;
    std::cout << "failed_steps:" << e->failed_steps << std::endl;
    std::cout << "y:";
    for (unsigned int i = 0; i < e->dimension; ++i)
        std::cout << y[i] << " ";
    std::cout << std::endl;

}

std::string {{component_name}}::ExceededMaximumSimultaneousTransitions::message() {
    std::ostringstream msg;
    msg << "Exceeded maxium number of simultaneous transitions (" << num_transitions << ")";
    msg << " in " << model << " at " << t << " ms. Probable infinite loop.";
    return msg.str();
}


{{component_name}}::Regime_::~Regime_() {
    for (std::vector<OnCondition_*>::iterator it = on_conditions.begin(); it != on_conditions.end(); ++it)
        delete *it;
    for (std::vector<OnEvent_*>::iterator it = on_events.begin(); it != on_events.end(); ++it)    
        delete *it;
}

{{component_name}}::Transition_* {{component_name}}::Regime_::transition(nest::Time const& origin, const nest::long_t& lag) {
    // Set the time to the end of the current timestep
    double t = origin.get_ms() + lag * nest::Time::get_resolution().get_ms();

    // Get vector of transitions (both OnConditions and OnEvents) that are triggered in the current timestep
    std::vector<Transition_*> occurred;
    for (std::vector<OnCondition_*>::iterator it = active_on_conditions.begin(); it != active_on_conditions.end(); ++it)
        if ((*it)->condition(t))
            occurred.push_back(*it);
            
    for (std::vector<OnEvent_*>::iterator it = on_events.begin(); it != on_events.end(); ++it)
        if ((*it)->received(origin, lag))
            occurred.push_back(*it);

    // Get the earliest transition to be triggered
    Transition_* transition;
    if (!occurred.size())
        transition = NULL;
    else if (occurred.size() == 1)
        transition = occurred[0];
    else {
        std::vector<double> times;
        for (std::vector<Transition_*>::iterator it = occurred.begin(); it != occurred.end(); ++it) 
            times.push_back((*it)->time_occurred(origin, lag));
        int min_index = std::min_element(times.begin(), times.end()) - times.begin();
        transition = occurred[min_index];
    }
    return transition;
}


void {{component_name}}::Regime_::set_triggers(double t) {
    // Reset the vector of active transitions
    active_on_conditions.clear();
    
    // Add OnConditions to the list of active transitions if their trigger condition evaluates to false
    for (std::vector<OnCondition_*>::iterator it = on_conditions.begin(); it != on_conditions.end(); ++it)
        if (!(*it)->condition(t))
            active_on_conditions.push_back(*it);
        
}


{% for regime in component_class.regimes %}

/**
 *  Dynamics and transitions for {{regime.name}} regime
 */

    {% if regime.num_time_derivatives %}
extern "C" int {{component_name}}_{{regime.name}}_dynamics{% include "dynamics_signature.tmpl" %} {

    // Get references to the members of the model
    assert(pnode_);
    const {{component_name}}& node_ = *(reinterpret_cast<{{component_name}}*>(pnode_));
    const {{component_name}}::Parameters_& P_ = node_.P_;
    const {{component_name}}::State_& S_ = node_.S_;
    const {{component_name}}::Buffers_& B_ = node_.B_;
    
    // State Variables from y_ vector
        {% for td in regime.time_derivatives %}
    double {{td.dependent_variable}} = ITEM(y_, {{component_name}}::{{regime.name}}Regime_::{{td.dependent_variable}}_INDEX);
        {% endfor %}

    {{macros.map_required_vars_locally(regime.time_derivatives, component_class, component_name, unit_handler, [], list(regime.time_derivative_variables)) | indent(4)}}

    // Evaluate differential equations
        {% for td, scaled_expr, units in unit_handler.scale_time_derivatives(regime.time_derivatives) %}
    ITEM(f_, {{component_name}}::{{regime.name}}Regime_::{{td.dependent_variable}}_INDEX) = {{scaled_expr.rhs_cstr}};  // ({{units}})
        {% endfor %}
	
    //std::cout << "Success at t=" << t << ": " << GSL_SUCCESS << std::endl;
        {% include "solver_return.tmpl" %}
}        
    {% endif %}
    
/* Jacobian for the {{regime.name}} regime if required by the solver */
    {% if regime.num_time_derivatives %}
{% include "solver_jacobian.tmpl" %}
    {% endif %}


{{component_name}}::{{regime.name}}Regime_::{{regime.name}}Regime_({{component_name}}* cell)
  : Regime_(cell, "{{regime.name}}"){% if regime.num_time_derivatives %}{% include "solver_construct.tmpl" %}{% endif %} {
  
    // Construct OnConditions specific to the regime.
    {% for on_condition in regime.on_conditions %}
    on_conditions.push_back(new {{regime.name}}OnCondition{{regime.index_of(on_condition)}}(this, "{{on_condition.target_regime.name}}"));
    {% endfor %}
	
    // Construct OnConditions specific to the regime.
    {% for on_event in regime.on_events %}
    on_events.push_back(new {{regime.name}}On{{on_event.src_port_name}}Event(this, "{{on_event.target_regime.name}}"));              
    {% endfor %}

}

{{component_name}}::{{regime.name}}Regime_::~{{regime.name}}Regime_() {
    {% if regime.num_time_derivatives %}    
    {% include "solver_destruct.tmpl" %}
    {% endif %}
}

void {{component_name}}::{{regime.name}}Regime_::init_solver() {
    {% if regime.num_time_derivatives %}    
    {% include "solver_init.tmpl" %}
    {% endif %}
    
}

void {{component_name}}::{{regime.name}}Regime_::step_ode() {
    {% if regime.num_time_derivatives %}
    // Copy states from cell state vector to the (potentially) truncated
    // regime-specific state vector (i.e. containing only the states that
    // have a derivative in the regime)
        {% for td in regime.time_derivatives %}
    ITEM(ode_y_, {{td.dependent_variable}}_INDEX) = cell->S_.y_[{{component_name}}::State_::{{td.dependent_variable}}_INDEX];
        {% endfor %}

    // Step ODE solver
{% include "solver_update.tmpl" %}
    
    // Copy states back from the regime-specific state vector to the cell
    // state vector
        {% for td in regime.time_derivatives %}
    cell->S_.y_[{{component_name}}::State_::{{td.dependent_variable}}_INDEX] = ITEM(ode_y_, {{td.dependent_variable}}_INDEX);
        {% endfor %}
    {% endif %}
}

// Transition methods for {{regime.name}} regime

    {% for transition in regime.transitions %}
        {% if transition.nineml_type == 'OnCondition' %}
            {% set TransitionClassName = '{}OnCondition{}'.format(regime.name, regime.index_of(transition)) %}
        {% else %}
            {% set TransitionClassName = '{}On{}Event'.format(regime.name, transition.src_port_name) %}
        {% endif %}

bool {{component_name}}::{{TransitionClassName}}::body(double t) {
    // Map all variables/expressions to the local namespace that are required to evaluate the state assignments that were not required for the triggers


    State_& S_ = regime->cell->S_;
    Buffers_& B_ = regime->cell->B_;
    const Parameters_& P_ = regime->cell->P_;
    Variables_& V_ = regime->cell->V_;
    
        {% if transition.nineml_type == 'OnEvent' %}
    // Get the next weight and remove it from the unprocessed list
    double_t weight_ = B_.{{transition.src_port_name}}_events->front();
    B_.{{transition.src_port_name}}_events->pop_front();
            {% if transition.src_port_name in component_class.connection_parameter_set_names %}
    // FIXME: Need to properly check beforehand that there is only one 
    //        connection parameter for this source port (which is a current
    //        limitaiton of NEST) before rendering the template. The following
    //        code will at least cause a compile error if there is
    double_t {{' '.join(component_class.connection_parameter_set(transition.src_port_name).parameter_names)}} = weight_;
            {% endif %}
        {% endif %}
    
    {{macros.map_required_vars_locally(transition.state_assignments, component_class, component_name, unit_handler, [], []) | indent(4)}}

    // State assignments
        {% for sa, scaled_expr, units in unit_handler.scale_aliases(transition.state_assignments) %}
    S_.y_[{{component_name}}::State_::{{sa.name}}_INDEX] = {{scaled_expr.rhs_cstr}};  // ({{units}})
        {% endfor %}
	        
    // Output events
        {% for output_event in transition.output_events %}
    ++B_.num_{{output_event.port.name}}_events;

        {% endfor %}
        
        {% if transition.num_state_assignments %}
    return true;  // Transition contains discontinuous changes in state
        {% else %}
    return false;  // Transition doesn't contain discontinuous changes in state
        {% endif %}
}

    {% endfor %}
    {% for on_event in regime.on_events %}
            {% set TransitionClassName = '{}On{}Event'.format(regime.name, on_event.src_port_name) %}
    
double {{component_name}}::{{TransitionClassName}}::time_occurred(nest::Time const& origin, const nest::long_t& lag) {
    //FIXME: Should use the exact spike time specified in the spike event
    return origin.get_ms() + lag * nest::Time::get_resolution().get_ms();
}


bool {{component_name}}::{{TransitionClassName}}::received(nest::Time const& origin, const nest::long_t& lag) {
    return (bool)regime->cell->B_.{{on_event.src_port_name}}_events->size();
}

    {% endfor %}
    {% for on_condition in regime.on_conditions %}
        {% set TransitionClassName = '{}OnCondition{}'.format(regime.name, regime.index_of(on_condition)) %}
bool {{component_name}}::{{TransitionClassName}}::condition(double t) {
	    
    const State_& S_ = regime->cell->S_;
    const Buffers_& B_ = regime->cell->B_;
    const Parameters_& P_ = regime->cell->P_;
        
    {{macros.map_required_vars_locally(on_condition.trigger, component_class, component_name, unit_handler, [], []) | indent(4)}}

    return {{on_condition.trigger.rhs_cstr}};

}

double {{component_name}}::{{TransitionClassName}}::time_occurred(nest::Time const& origin, const nest::long_t& lag) {
       {% set exact_time_expr = on_condition.trigger.crossing_time_expr %}
       {% if exact_time_expr %}

    const State_& S_ = regime->cell->S_;
    const Buffers_& B_ = regime->cell->B_;
    const Parameters_& P_ = regime->cell->P_;
       
    {{macros.map_required_vars_locally(exact_time_expr, component_class, component_name, unit_handler, [], []) | indent(4)}}       
    // The trigger expression depends on 't' so determine the exact time that the threshold was crossed.
    return {{exact_time_expr.rhs_cstr}};
       {% else %}
    return origin.get_ms() + lag * nest::Time::get_resolution().get_ms();
       {% endif %}
}

	{% endfor %}
{% endfor %}


/**********************************************
 * Calculation of the residual for IDA solver *
 **********************************************/

{% include "residual.tmpl" %}

/***********************
 * Steady-sate solvers *
 ***********************/

{% include "fsolve.tmpl" %}

{# ********Old steady state implementation*******
{% if steadystate.localVars %}
  double {{steadystate.localVars | join(", ")}};
{% endif %}

  // params is a reference to the model parameters
  const struct {{component_name}}::Parameters_* params = (struct {{component_name}}::Parameters_ *)pnode;

{% for parameterDef in steadystate.parameterDefs %}
  {{parameterDef}}
{% endfor %}

{% for eq in steadystate.SSgetStateDefs %}
  {{eq}}
{% endfor %}

{% for eq in steadystate.SScurrentEqDefs %}
  {{eq}}
{% endfor %}

{% for eq in init.initOrder %}
  {{eq}}
{% endfor %}

{% for x in steadystate.SSsetStateDefsLbs %}
    {% if x.lbs %}
  double {{x.lbs | join(", ")}};
    {% endif %}

    {% for eq in x.defs %}
  {{eq}}
    {% endfor %}

{% endfor %}
***************************#}


/****************
 * Constructors *
 ****************/

{{component_name}}::{{component_name}}()
    : Archiving_Node(),
      P_(),
      S_(P_),
      B_(*this) {

    recordablesMap_.create();
    construct_regimes();
        
}

{{component_name}}::{{component_name}}(const {{component_name}}& n)
    : Archiving_Node(n),
      P_(n.P_),
      S_(n.S_),
      B_(n.B_, *this) {
      
    construct_regimes();
}

/**
 * Constructs all regimes (and their transitions) in the component class
 */      
void {{component_name}}::construct_regimes() {

    // Construct all regimes
{% for regime in component_class.regimes %}
    regimes["{{regime.name}}"] = new {{regime.name}}Regime_(this);
{% endfor %}

    // Set target regimes in all transitions
    Regime_* regime;

{% for regime in component_class.regimes %}
    regime = get_regime("{{regime.name}}");
    for (std::vector<OnEvent_*>::iterator it = regime->on_events.begin(); it != regime->on_events.end(); ++it)
        (*it)->set_target_regime(regimes);
    for (std::vector<OnCondition_*>::iterator it = regime->on_conditions.begin(); it != regime->on_conditions.end(); ++it)
        (*it)->set_target_regime(regimes);   
{% endfor %}
}

void {{component_name}}::init_node_(const Node& proto) {
    const {{component_name}}& pr = downcast<{{component_name}}>(proto);
    P_ = pr.P_;
    S_ = State_(P_);
}

void {{component_name}}::init_state_(const Node& proto) {
    const {{component_name}}& pr = downcast<{{component_name}}>(proto);
    S_ = State_(pr.P_);
}

/**************
 * Destructor *
 **************/

{{component_name}}::~{{component_name}} () {
    // Destruct all regimes
    for (std::map<std::string, Regime_*>::iterator it = regimes.begin(); it != regimes.end(); ++it)
        delete it->second;
    regimes.clear();
}


/**********************************
 * Define parameters of the model *
 **********************************/

{{component_name}}::Parameters_::Parameters_()
{% for i, param in enumerate(component_class.parameters) %}
  {%if loop.first%}:{% endif %}
    {{param.name}} (0.0){% if not loop.last %},
{% endif %}
{% endfor %} {
// Check constraints on parameters
{#
{% for param in component_class.parameters %}
    {% for constraint in param.constraints %}
    {{constraint}}
    {% endfor %}
{% endfor %}
#}
}

/************************************
 * Construct state from parameters.
 ************************************/

{{component_name}}::State_::State_(const Parameters_& p) {

    const Parameters_ *params = &p;

    // FIXME: need to add initial state here
{% for sv in component_class.state_variables %}
    y_[{{sv.name}}_INDEX] = 0.0;
{% endfor %}

{% include "solve_steady_state.tmpl" %}
}

/***********************************
 * Copy constructor for State class
 ***********************************/
{{component_name}}::State_::State_(const State_& s) {
{% if component_class.num_state_variables %}
  for (int i = 0; i < {{component_class.num_state_variables}}; ++i)
      y_[i] = s.y_[i];
{% endif %}
}

/********************************************
 * Assignment of a State from another State *
 ********************************************/

{{component_name}}::State_& {{component_name}}::State_::operator=(const State_& s) {
  assert(this != &s);
{% if component_class.num_state_variables %}
  for (size_t i = 0 ; i < {{component_class.num_state_variables}} ; ++i)
       y_[i] = s.y_[i];
{% endif %}
  return *this;
}

void {{component_name}}::calibrate() {
    B_.logger_.init();
    V_.rng_ = net_->get_rng( get_thread() );
}

/***************************
 * Accessors and Modifiers *
 ***************************/

void {{component_name}}::Parameters_::get (DictionaryDatum &d_) const {

{# TODO: Should change this to names::{{name}}, {{name}} once I work out where
         to put the "names" declarations (probably in the header#}
    // Update dictionary from internal parameters, scaling if required.
{% for p in component_class.parameters %}
    def<double_t>(d_, "{{p.name}}", {{p.name}}{% if name in parameter_scales %} / {{parameter_scales[name]}}{% endif %});
{% endfor %}

}

void {{component_name}}::Parameters_::set (const DictionaryDatum &d_) {

    // Update internal parameters from dictionary
{% for p in component_class.parameters %}
    updateValue<double_t>(d_, "{{p.name}}", {{p.name}});
{% endfor %}

    // Scale parameters as required
{# Not sure if this is necessary
{% for name, scale in parameter_scales) %}
    {{name}} *= {{scale}};
{% endfor %}
#}
}

void {{component_name}}::State_::get (DictionaryDatum &d_) const {
    // Get states from internal variables
{% for i, sv in enumerate(component_class.state_variables) %}
    def<double_t>(d_, "{{sv.name}}", y_[{{i}}]);
{% endfor %}
}

void {{component_name}}::State_::set (const DictionaryDatum &d_, const Parameters_&) {
    // Set internal state variables from dictionary values
{% for i, sv in enumerate(component_class.state_variables) %}
    updateValue<double_t>(d_, "{{sv.name}}", y_[{{i}}]);
{% endfor %}
}

/***********
 * Buffers *
 ***********/

{{component_name}}::Buffers_::Buffers_({{component_name}}& n)
    : logger_(n) {
    // Initialization of the remaining members is deferred to
    // init_buffers_().
}

{{component_name}}::Buffers_::Buffers_(const Buffers_&, {{component_name}}& n)
    : logger_(n) {
    // Initialization of the remaining members is deferred to
    // init_buffers_().
}

void {{component_name}}::init_buffers_() {

    // Clear event buffers
{% for p in component_class.event_receive_ports %}
    B_.{{p.name}}_event_port.clear();
{% endfor %}

    // Clear analog buffers
{% for p in chain(component_class.analog_receive_ports, component_class.analog_reduce_ports) %}
    B_.{{p.name}}_analog_port.clear();
{% endfor %}

    Archiving_Node::clear_history();

    B_.logger_.reset();

    B_.step_ = nest::Time::get_resolution().get_ms();

{% for p in chain(component_class.analog_receive_ports, component_class.analog_reduce_ports) %}
    B_.{{p.name}}_value = 0.0;
{% endfor %}

    B_.current_regime = get_regime("{{default_regime}}");
    B_.current_regime->set_triggers(0);
    B_.current_regime->init_solver();

}


void {{component_name}}::refresh_events(const nest::long_t& lag) {
{% for port in component_class.event_send_ports %}
    B_.num_{{port.name}}_events = 0;
{% endfor %}
{% for port in component_class.event_receive_ports %}
    B_.{{port.name}}_events = &B_.{{port.name}}_event_port.get_list(lag);
{% endfor %}
}

/************************************************************************
 * Function to be solved for its roots be solver to exact trigger times *
 ************************************************************************/

{% include "trigger_roots.tmpl" %}

/***********************
 * Evaluate the update *
 ***********************/

void {{component_name}}::update(nest::Time const & origin, const nest::long_t from, const nest::long_t to) {

    assert(to >= 0 && (nest::delay) from < nest::Scheduler::get_min_delay());
    assert(from < to);

    nest::long_t current_steps = origin.get_steps();

    for (nest::long_t lag = from; lag < to; ++lag) {

        /***** Solve ODE over timestep *****/
        B_.current_regime->step_ode();

        /***** Transition handling *****/
        // Get multiplicity incoming events for the current lag and reset multiplicity of outgoing events
        refresh_events(lag);
        
        Transition_* transition;
        int simultaneous_transition_count = 0;
        double prev_t = origin.get_ms();
        while ((transition = B_.current_regime->transition(origin, lag))) {  // Check for a transition (i.e. the output of current_regime->transition is not NULL) and record it in the 'transition' variable.
                    
            double t = transition->time_occurred(origin, lag);  // Get the exact time the transition occurred.
            if (t == prev_t) {
                ++simultaneous_transition_count;
                if (simultaneous_transition_count > MAX_SIMULTANEOUS_TRANSITIONS)
                    throw ExceededMaximumSimultaneousTransitions("{{component_name}}", simultaneous_transition_count, t);
            } else
                simultaneous_transition_count = 0;
            // Execute body of transition, flagging a discontinuity in the ODE system
            // if either the body contains state assignments (i.e. not just output
            // events) or the regime changes
            bool discontinuous = transition->body(t) || (transition->get_target_regime() != B_.current_regime);
            // Update the current regime
            B_.current_regime = transition->get_target_regime();
            // Set all triggers, i.e. activate all triggers for which their trigger condition 
            // evaluates to false.
            B_.current_regime->set_triggers(t);
            // Reinitialise the solve if the is a discontinuity in the ODE system
            if (discontinuous)
                B_.current_regime->init_solver();  // Reset the solver if the transition contains state assignments or switches to a new regime.
        }
        
        /***** Send output events for each event send port *****/
        // FIXME: Need to specify different output ports in a way that can be read by the receiving nodes
        // Output events        
{% for port in component_class.event_send_ports %}
        if (B_.num_{{port.name}}_events) {
		    set_spiketime(nest::Time::step(origin.get_steps()+lag+1));
		    nest::SpikeEvent se;
		    se.set_multiplicity(B_.num_{{port.name}}_events);
		    network()->send(*this, se, lag); 
        }
{% endfor %}

        /***** Get analog port values *****/
{% for port in chain(component_class.analog_receive_ports, component_class.analog_reduce_ports) %}
        B_.{{port.name}}_value = B_.{{port.name}}_analog_port.get_value(lag);
{% endfor %}

        /***** Record data *****/
        B_.logger_.record_data(current_steps + lag);
    }
}

/*****************
 * Event Handles *
 *****************/

void {{component_name}}::handle(nest::SpikeEvent & e) {
    assert(e.get_delay() > 0);   
    
    //std::cout << "spike time: " << network()->get_slice_origin().get_ms() + e.get_rel_delivery_steps(network()->get_slice_origin()) * nest::Time::get_resolution().get_ms() << std::endl;

    // Get buffer for event receive port
    nest::ListRingBuffer* event_buffer;
{% for port in component_class.event_receive_ports %}
    {{elseif(loop.first)}} (e.get_rport() == {{port.name}}_EVENT_PORT) {
        event_buffer = &B_.{{port.name}}_event_port;
    {% if loop.last %}
    } else
    {% endif %}
{% endfor %}
        assert(false);  // Unrecognised port 
    
    const unsigned int multiplicity = e.get_multiplicity();
    const unsigned int lag = e.get_rel_delivery_steps(network()->get_slice_origin()); 
    const double_t weight = e.get_weight();

    // Append received events to buffer
    for (unsigned int i = 0; i < multiplicity; ++i)
        event_buffer->append_value(lag, weight);

}

void {{component_name}}::handle(nest::CurrentEvent& e) {
    assert(e.get_delay() > 0);

    //Get buffer for current receive port
    nest::RingBuffer* current_buffer;
{% for port in chain(component_class.analog_receive_ports, component_class.analog_reduce_ports) %}
    {{elseif(loop.first)}} (e.get_rport() == {{port.name}}_ANALOG_PORT) {
        current_buffer = &B_.{{port.name}}_analog_port;
    {% if loop.last %}
    } else
    {% endif %}        
{% endfor %}
        assert(false);  // Unrecognised port

    const double_t c = e.get_current();
    const double_t w = e.get_weight();
    const unsigned int lag = e.get_rel_delivery_steps(network()->get_slice_origin());

    // Append current value for lag
    current_buffer->add_value(lag, w * c);

}

void {{component_name}}::handle(nest::DataLoggingRequest& e) {
    B_.logger_.handle(e);
}


}  // End 'nineml' namespace
