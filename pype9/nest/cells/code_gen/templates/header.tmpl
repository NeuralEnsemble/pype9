{# This template provides a CVODE exception class

   Authors: Thomas G. Close and Ivan Raikov
   Copyright Okinawa Institute of Science and Technology Graudate University 2014
#}

/* This file was generated by PyPe9 version {{version}} on {{timestamp}} */

#ifndef {{component_name | upper}}_H
#define {{component_name | upper}}_H

#include "nest.h"
#include "event.h"
//#include "node.h"
#include "archiving_node.h"
#include "ring_buffer.h"
#include "connection.h"
#include "universal_data_logger.h"
#include "recordables_map.h"

{% include "solver_includes.tmpl" %}

{% include "ss_solver_includes.tmpl" %}

{% include "item_macro.tmpl" %}

namespace nineml {

{% include "solver_preludes.tmpl" %}
{% include "ss_solver_preludes.tmpl" %}

{% for regime in component_class.regimes %}
    extern "C" {% include "dynamics_signature.tmpl" %};
    {% include "residual_signature.tmpl" %}
    {% include "event_signature.tmpl" %}
    {% include "ss_signature.tmpl" %}
{% endfor %}

    class {{component_name}} : public nest::Archiving_Node {

      public:

        ~{{component_name}}();
	    {{component_name}}(const {{component_name}} &);
	    {{component_name}}();
	
	    /**
	     * Import sets of overloaded virtual functions.
	     * This is necessary to ensure proper overload and overriding resolution.
	     * @see http://www.gotw.ca/gotw/005.htm.
	     */
	    using nest::Node::handle;
	    using nest::Node::handles_test_event;
	
	    nest::port send_test_event(nest::Node&, nest::port, nest::synindex, bool);
	
	    void handle(nest::SpikeEvent &);
	    void handle(nest::CurrentEvent &);
	    void handle(nest::DataLoggingRequest &);
	
	    nest::port handles_test_event(nest::SpikeEvent &, nest::port);
	    nest::port handles_test_event(nest::CurrentEvent &, nest::port);
	    nest::port handles_test_event(nest::DataLoggingRequest &, nest::port);
	
	    void get_status(DictionaryDatum &) const;
	    void set_status(const DictionaryDatum &);
	
	    void init_node_(const nest::Node& proto);
	    void init_state_(const nest::Node& proto);
	    void init_buffers_();
	    void calibrate();
	
	    void update(nest::Time const &, const nest::long_t, const nest::long_t);

    // Set dynamics methods (the ones that actually model the dynamics) as friends
{% for regime in component_class.regimes %}
	    friend {% include "dynamics_signature.tmpl" %};
	    {% include "residual_friend.tmpl" %}
	    {% include "event_friend.tmpl" %}
	    {% include "ss_friend.tmpl" %}
{% endfor %}

	    // Regime ids
	    static const int DEFAULT_REGIME_ = 0;
	    enum Regimes {
	        {% for regime in component_class.regimes %}
	            {% if loop.first %}
	        {{regime.name}}_REGIME = DEFAULT_REGIME_,
	            {% else %}
	        {{regime.name}}_REGIME,
	            {% endif -%}
	        {% endfor %}
	        SUP_REGIME_
	    };


{% if component_class.event_receive_ports %}
	    /* Event port ids
	     * @note Start with 1 so we can forbid port 0 to avoid accidental
	     *     creation of connections with no receptor type set.
	     */
	    static const nest::port MIN_EVENT_PORT_ = 1;
	    enum EventPorts {
    {% for port in component_class.event_receive_ports %}
        {% if loop.first %}
	        {{port.name}}_EVENT_PORT = MIN_EVENT_PORT_,
        {% else %}
	        {{port.name}}_EVENT_PORT,
        {% endif %}
    {% endfor %}
	        SUP_EVENT_PORT_
	    };
	
	    // On event ids
	    enum OnEvents {
    {% for regime in component_class.regimes %}
        {% for oe in regime.on_events %}
	        {{regime.name}}_{{oe.src_port_name}}_ON_EVENT,
        {% endfor %}
    {% endfor %}
	        SUP_ON_EVENT_
	    };

{% endif %}
{% if component_class.analog_receive_ports %}
	    //Analog port ids
	    static const nest::port MIN_ANALOG_PORT_ = 1;
	    enum AnalogPorts {
    {% for port in chain(component_class.analog_receive_ports, component_class.analog_reduce_ports) %}
        {% if loop.first %}
            {{port.name}}_ANALOG_PORT = MIN_ANALOG_PORT_,
        {% else %}
            {{port.name}}_ANALOG_PORT,
        {% endif %}
    {% endfor %}
            SUP_ANALOG_PORT_
        };


{% endif %}
        // Synaptic event function definitions
{% for regime in component_class.regimes %}
    {% for oe in regime.on_events %}
        inline void {{oe.src_port_name}}_event_in_{{regime.name}}(nest::long_t lag);
    {% endfor %}
{% endfor %}

	    // The next two classes need to be friends to access the State_ class/member
	    friend class nest::RecordablesMap<{{component_name}}>;
	    friend class nest::UniversalDataLogger<{{component_name}}>;
	
        struct Parameters_ {
{% for param in component_class.parameters %}
            double {{param.name}};
{% endfor %}
	        Parameters_();
	        void get(DictionaryDatum&) const;
	        void set(const DictionaryDatum&);
	    }; // end struct Parameters_

	    struct State_ {
	
            enum StateVecElems {
{% for sv in component_class.state_variables %}
    {% if loop.first %}
                {{sv.name}}_INDEX = 0,
    {% else %}
                {{sv.name}}_INDEX,
    {% endif %}
{% endfor %}
                STATE_VEC_SIZE_
            };

            double y_[STATE_VEC_SIZE_];

	        State_(const Parameters_& p);
	        State_(const State_& s);
	        State_& operator=(const State_& s);
	        void get(DictionaryDatum&) const;
	        void set(const DictionaryDatum&, const Parameters_&);
	    }; // end struct State_

        struct Variables_ {};

        struct Buffers_ {
	        Buffers_({{component_name}}&);
	        Buffers_(const Buffers_&, {{component_name}}&);
	        nest::UniversalDataLogger<{{component_name}}> logger_;

            // Structures required by the solver
{% include "solver_work_vars.tmpl" %}

	        // Timesteps
	        double_t step_;       //!< step size in ms
	        double   IntegrationStep_;//!< current integration time step, updated by solver
	
	        // Event receive port buffers
{% for port in component_class.event_receive_ports %}
            nest::RingBuffer {{port.name}}_event_port;
{% endfor %}

            // Analog receive port buffers
{% for port in chain(component_class.analog_receive_ports, component_class.analog_reduce_ports) if port.name not in event_weights.itervalues() %}
            nest::RingBuffer {{port.name}}_analog_port;
{% endfor %}

            // Variables to hold the last value of the analog receive port buffers
{% for port in chain(component_class.analog_receive_ports, component_class.analog_reduce_ports) if port.name not in event_weights.itervalues() %}
            double_t {{port.name}}_value;
{% endfor %}

            // Flags to signify whether the triggers are active (i.e. evaluated to false in the last time step)
{% for regime in component_class.regimes %}
    {% for oc in regime.on_conditions %}
            bool {{regime.name}}_trigger_{{regime.index_of(oc)}}_active;
    {% endfor %}
{% endfor %}

            // Holds the id of the current regime
            int current_regime;

	    }; // end struct Buffers_


		template <State_::StateVecElems elem>
		double_t get_y_elem_() const { return S_.y_[elem]; }
	
		Parameters_ P_;
		State_      S_;
		Variables_  V_;
		Buffers_    B_;
	
	    //! Mapping of recordables names to access functions	
		static nest::RecordablesMap<{{component_name}}> recordablesMap_;
	
	}; // end class {{component_name}}

    inline nest::port {{component_name}}::send_test_event(nest::Node& target, nest::port receptor_type, nest::synindex, bool) {
		nest::SpikeEvent e;
		e.set_sender(*this);
		return target.handles_test_event(e, receptor_type);
    }
	
    inline nest::port {{component_name}}::handles_test_event(nest::SpikeEvent&, nest::port receptor_type) {
	    if (receptor_type < 0 || receptor_type >= SUP_EVENT_PORT_)
            throw nest::UnknownReceptorType(receptor_type, this->get_name());
        else if (receptor_type < MIN_EVENT_PORT_)
            throw nest::IncompatibleReceptorType(receptor_type, this->get_name(), "SpikeEvent");
		return receptor_type;
    }
		
		
    inline nest::port {{component_name}}::handles_test_event(nest::CurrentEvent&, nest::port receptor_type) {
		if (receptor_type < 0 || receptor_type >= SUP_ANALOG_PORT_)
		    throw nest::UnknownReceptorType(receptor_type, this->get_name());
		else if (receptor_type < MIN_ANALOG_PORT_)
		    throw nest::IncompatibleReceptorType(receptor_type, this->get_name(), "SpikeEvent");
	    return receptor_type;
	}
		
		
	inline nest::port {{component_name}}::handles_test_event(nest::DataLoggingRequest& dlr, nest::port receptor_type) {
	    if (receptor_type != 0)
            throw nest::UnknownReceptorType(receptor_type, this->get_name());
		return B_.logger_.connect_logging_device( dlr, recordablesMap_ );
    }
		
		
    inline void {{component_name}}::get_status(DictionaryDatum &d) const {
		P_.get(d);
		S_.get(d);
		nest::Archiving_Node::get_status(d);
		(*d)[nest::names::recordables] = recordablesMap_.get_list();
		def<double_t>(d, nest::names::t_spike, get_spiketime_ms());
		DictionaryDatum receptor_dict_ = new Dictionary();
		// Synaptic event dictionary
{% for port in component_class.event_receive_ports %}
        (*receptor_dict_)[Name("{{port.name}}")]  = {{port.name}}_EVENT_PORT;
{% endfor %}
{% for port in chain(component_class.analog_receive_ports, component_class.analog_reduce_ports) %}
        (*receptor_dict_)[Name("{{port.name}}")]  = {{port.name}}_ANALOG_PORT;
{% endfor %}
        (*d)[nest::names::receptor_types] = receptor_dict_;
    }


    inline void {{component_name}}::set_status(const DictionaryDatum &d) {
	    Parameters_ ptmp = P_;  // temporary copy in case of errors
	    ptmp.set(d);             // throws if BadProperty
	    State_    stmp = S_;  // temporary copy in case of errors
	    stmp.set(d, ptmp);         // throws if BadProperty
	    // We now know that (ptmp, stmp) are consistent. We do not
	    // write them back to (P_, S_) before we are also sure that
		// the properties to be set in the parent class are internally
		// consistent.
		nest::Archiving_Node::set_status(d);
		// if we get here, temporaries contain consistent set of properties
		P_ = ptmp;
		S_ = stmp;	
	    calibrate();
    }

} // end namespace nest

#endif // {{component_name | upper}}_H
